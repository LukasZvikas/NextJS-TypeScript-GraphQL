"use strict";exports.__esModule=true;exports.default=build;var _chalk=_interopRequireDefault(require("chalk"));var _constants=require("next-server/constants");var _nextConfig=_interopRequireDefault(require("next-server/next-config"));var _index=_interopRequireDefault(require("next/dist/compiled/nanoid/index.js"));var _path=_interopRequireDefault(require("path"));var _formatWebpackMessages=_interopRequireDefault(require("../client/dev-error-overlay/format-webpack-messages"));var _recursiveDelete=require("../lib/recursive-delete");var _verifyTypeScriptSetup=require("../lib/verifyTypeScriptSetup");var _compiler=require("./compiler");var _entries=require("./entries");var _flyingShuttle=require("./flying-shuttle");var _generateBuildId=require("./generate-build-id");var _isWriteable=require("./is-writeable");var _utils=require("./utils");var _webpackConfig=_interopRequireDefault(require("./webpack-config"));var _chunkGraphPlugin=require("./webpack/plugins/chunk-graph-plugin");var _writeBuildId=require("./write-build-id");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}async function build(dir,conf=null){if(!(await(0,_isWriteable.isWriteable)(dir))){throw new Error('> Build directory is not writeable. https://err.sh/zeit/next.js/build-dir-not-writeable');}await(0,_verifyTypeScriptSetup.verifyTypeScriptSetup)(dir);const debug=process.env.__NEXT_BUILDER_EXPERIMENTAL_DEBUG==='true'||process.env.__NEXT_BUILDER_EXPERIMENTAL_DEBUG==='1';console.log(debug?'Creating a development build ...':'Creating an optimized production build ...');console.log();const config=(0,_nextConfig.default)(_constants.PHASE_PRODUCTION_BUILD,dir,conf);const target=process.env.__NEXT_BUILDER_EXPERIMENTAL_TARGET||config.target;const buildId=debug?'unoptimized-build':await(0,_generateBuildId.generateBuildId)(config.generateBuildId,_index.default);const distDir=_path.default.join(dir,config.distDir);const pagesDir=_path.default.join(dir,'pages');const isFlyingShuttle=Boolean(config.experimental.flyingShuttle&&!process.env.__NEXT_BUILDER_EXPERIMENTAL_PAGE);const selectivePageBuilding=Boolean(isFlyingShuttle||process.env.__NEXT_BUILDER_EXPERIMENTAL_PAGE);if(selectivePageBuilding&&target!=='serverless'){throw new Error(`Cannot use ${isFlyingShuttle?'flying shuttle':'`now dev`'} without the serverless target.`);}const selectivePageBuildingCacheIdentifier=selectivePageBuilding?await(0,_utils.getCacheIdentifier)({pagesDirectory:pagesDir,env:config.env||{}}):'noop';let flyingShuttle;if(isFlyingShuttle){console.log(_chalk.default.magenta('Building with Flying Shuttle enabled ...'));console.log();await(0,_recursiveDelete.recursiveDelete)(distDir,/^(?!cache(?:[\/\\]|$)).*$/);await(0,_recursiveDelete.recursiveDelete)(_path.default.join(distDir,'cache','next-minifier'));await(0,_recursiveDelete.recursiveDelete)(_path.default.join(distDir,'cache','next-babel-loader'));flyingShuttle=new _flyingShuttle.FlyingShuttle({buildId,pagesDirectory:pagesDir,distDirectory:distDir,cacheIdentifier:selectivePageBuildingCacheIdentifier});}let pagePaths;if(process.env.__NEXT_BUILDER_EXPERIMENTAL_PAGE){pagePaths=await(0,_utils.getSpecifiedPages)(dir,process.env.__NEXT_BUILDER_EXPERIMENTAL_PAGE,config.pageExtensions);}else{pagePaths=await(0,_utils.collectPages)(pagesDir,config.pageExtensions);}if(flyingShuttle&&(await flyingShuttle.hasShuttle())){const _unchangedPages=new Set((await flyingShuttle.getUnchangedPages()));for(const unchangedPage of _unchangedPages){const recalled=await flyingShuttle.restorePage(unchangedPage);if(recalled){continue;}_unchangedPages.delete(unchangedPage);}const unchangedPages=await Promise.all([..._unchangedPages].map(async page=>{const file=await(0,_utils.getFileForPage)({page,pagesDirectory:pagesDir,pageExtensions:config.pageExtensions});if(file){return file;}return Promise.reject(new Error(`Failed to locate page file: ${page}. `+`Did pageExtensions change? We can't recover from this yet.`));}));const pageSet=new Set(pagePaths);for(const unchangedPage of unchangedPages){pageSet.delete(unchangedPage);}pagePaths=[...pageSet];}const mappedPages=(0,_entries.createPagesMapping)(pagePaths,config.pageExtensions);const entrypoints=(0,_entries.createEntrypoints)(mappedPages,target,buildId,/* dynamicBuildId */selectivePageBuilding,config);const configs=await Promise.all([(0,_webpackConfig.default)(dir,{debug,buildId,isServer:false,config,target,entrypoints:entrypoints.client,selectivePageBuilding}),(0,_webpackConfig.default)(dir,{debug,buildId,isServer:true,config,target,entrypoints:entrypoints.server,selectivePageBuilding})]);let result={warnings:[],errors:[]};if(target==='serverless'){if(config.publicRuntimeConfig)throw new Error('Cannot use publicRuntimeConfig with target=serverless https://err.sh/zeit/next.js/serverless-publicRuntimeConfig');const clientResult=await(0,_compiler.runCompiler)(configs[0]);// Fail build if clientResult contains errors
if(clientResult.errors.length>0){result={warnings:[...clientResult.warnings],errors:[...clientResult.errors]};}else{const serverResult=await(0,_compiler.runCompiler)(configs[1]);result={warnings:[...clientResult.warnings,...serverResult.warnings],errors:[...clientResult.errors,...serverResult.errors]};}}else{result=await(0,_compiler.runCompiler)(configs);}result=(0,_formatWebpackMessages.default)(result);if(isFlyingShuttle){console.log();(0,_chunkGraphPlugin.exportManifest)({dir:dir,fileName:_path.default.join(distDir,_constants.CHUNK_GRAPH_MANIFEST),selectivePageBuildingCacheIdentifier});}if(result.errors.length>0){// Only keep the first error. Others are often indicative
// of the same problem, but confuse the reader with noise.
if(result.errors.length>1){result.errors.length=1;}const error=result.errors.join('\n\n');console.error(_chalk.default.red('Failed to compile.\n'));console.error(error);console.error();if(error.indexOf('private-next-pages')>-1){throw new Error('> webpack config.resolve.alias was incorrectly overriden. https://err.sh/zeit/next.js/invalid-resolve-alias');}throw new Error('> Build failed because of webpack errors');}else if(result.warnings.length>0){console.warn(_chalk.default.yellow('Compiled with warnings.\n'));console.warn(result.warnings.join('\n\n'));console.warn();}else{console.log(_chalk.default.green('Compiled successfully.\n'));}const pageInfos=new Map();const distPath=_path.default.join(dir,config.distDir);const pageKeys=Object.keys(mappedPages);for(const page of pageKeys){const chunks=(0,_chunkGraphPlugin.getPageChunks)(page);const actualPage=page==='/'?'/index':page;const size=await(0,_utils.getPageSizeInKb)(actualPage,distPath,buildId);pageInfos.set(page,{size,chunks});}if(Array.isArray(configs[0].plugins)){configs[0].plugins.some(plugin=>{if(!plugin.ampPages){return false;}plugin.ampPages.forEach(pg=>{pageInfos.get(pg).isAmp=true;});return true;});}(0,_utils.printTreeView)(pageKeys,pageInfos);if(flyingShuttle){await flyingShuttle.save();}await(0,_writeBuildId.writeBuildId)(distDir,buildId,selectivePageBuilding);}