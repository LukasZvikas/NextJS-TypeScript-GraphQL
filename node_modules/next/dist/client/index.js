"use strict";var _interopRequireWildcard=require("@babel/runtime-corejs2/helpers/interopRequireWildcard");var _interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault");exports.__esModule=true;exports.render=render;exports.renderError=renderError;exports.default=exports.emitter=exports.ErrorComponent=exports.router=exports.dataManager=void 0;var _extends2=_interopRequireDefault(require("@babel/runtime-corejs2/helpers/extends"));var _promise=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));var _react=_interopRequireWildcard(require("react"));var _reactDom=_interopRequireDefault(require("react-dom"));var _headManager=_interopRequireDefault(require("./head-manager"));var _router2=require("next/router");var _mitt=_interopRequireDefault(require("next-server/dist/lib/mitt"));var _utils=require("next-server/dist/lib/utils");var _pageLoader=_interopRequireDefault(require("./page-loader"));var envConfig=_interopRequireWildcard(require("next-server/config"));var _errorBoundary=require("./error-boundary");var _loadable=_interopRequireDefault(require("next-server/dist/lib/loadable"));var _headManagerContext=require("next-server/dist/lib/head-manager-context");var _dataManagerContext=require("next-server/dist/lib/data-manager-context");var _routerContext=require("next-server/dist/lib/router-context");var _dataManager=require("next-server/dist/lib/data-manager");// Polyfill Promise globally
// This is needed because Webpack's dynamic loading(common chunks) code
// depends on Promise.
// So, we need to polyfill it.
// See: https://webpack.js.org/guides/code-splitting/#dynamic-imports
if(!window.Promise){window.Promise=_promise.default;}const data=JSON.parse(document.getElementById('__NEXT_DATA__').textContent);window.__NEXT_DATA__=data;const props=data.props,err=data.err,page=data.page,query=data.query,buildId=data.buildId,dynamicBuildId=data.dynamicBuildId,assetPrefix=data.assetPrefix,runtimeConfig=data.runtimeConfig,dynamicIds=data.dynamicIds;const d=JSON.parse(window.__NEXT_DATA__.dataManager);const dataManager=new _dataManager.DataManager(d);exports.dataManager=dataManager;const prefix=assetPrefix||'';// With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time
// So, this is how we do it in the client side at runtime
__webpack_public_path__=`${prefix}/_next/`;//eslint-disable-line
// Initialize next/config with the environment configuration
envConfig.setConfig({serverRuntimeConfig:{},publicRuntimeConfig:runtimeConfig});const asPath=(0,_utils.getURL)();const pageLoader=new _pageLoader.default(buildId,prefix);const register=([r,f])=>pageLoader.registerPage(r,f);if(window.__NEXT_P){window.__NEXT_P.map(register);}window.__NEXT_P=[];window.__NEXT_P.push=register;const headManager=new _headManager.default();const appContainer=document.getElementById('__next');let lastAppProps;let webpackHMR;let router;exports.router=router;let ErrorComponent;exports.ErrorComponent=ErrorComponent;let Component;let App;const emitter=(0,_mitt.default)();exports.emitter=emitter;var _default=async({webpackHMR:passedWebpackHMR}={})=>{// This makes sure this specific line is removed in production
if(process.env.NODE_ENV==='development'){webpackHMR=passedWebpackHMR;}App=await pageLoader.loadPage('/_app');let initialErr=err;try{Component=await pageLoader.loadPage(page);if(process.env.NODE_ENV!=='production'){const _require=require('react-is'),isValidElementType=_require.isValidElementType;if(!isValidElementType(Component)){throw new Error(`The default export is not a React Component in page: "${page}"`);}}}catch(error){// This catches errors like throwing in the top level of a module
initialErr=error;}await _loadable.default.preloadReady(dynamicIds||[]);if(dynamicBuildId===true){pageLoader.onDynamicBuildId();}exports.router=router=(0,_router2.createRouter)(page,query,asPath,{initialProps:props,pageLoader,App,Component,err:initialErr});router.subscribe(({App,Component,props,err})=>{render({App,Component,props,err,emitter});});render({App,Component,props,err:initialErr,emitter});return emitter;};exports.default=_default;async function render(props){if(props.err){await renderError(props);return;}try{await doRender(props);}catch(err){await renderError((0,_extends2.default)({},props,{err}));}}// This method handles all runtime and debug errors.
// 404 and 500 errors are special kind of errors
// and they are still handle via the main render method.
async function renderError(props){const App=props.App,err=props.err;if(process.env.NODE_ENV!=='production'){return webpackHMR.reportRuntimeError(webpackHMR.prepareError(err));}// Make sure we log the error to the console, otherwise users can't track down issues.
console.error(err);exports.ErrorComponent=ErrorComponent=await pageLoader.loadPage('/_error');// In production we do a normal render with the `ErrorComponent` as component.
// If we've gotten here upon initial render, we can use the props from the server.
// Otherwise, we need to call `getInitialProps` on `App` before mounting.
const initProps=props.props?props.props:await(0,_utils.loadGetInitialProps)(App,{Component:ErrorComponent,router,ctx:{err,pathname:page,query,asPath}});await doRender((0,_extends2.default)({},props,{err,Component:ErrorComponent,props:initProps}));}let isInitialRender=true;function renderReactElement(reactEl,domEl){// The check for `.hydrate` is there to support React alternatives like preact
if(isInitialRender&&typeof _reactDom.default.hydrate==='function'){_reactDom.default.hydrate(reactEl,domEl);isInitialRender=false;}else{_reactDom.default.render(reactEl,domEl);}}async function doRender({App,Component,props,err}){// Usual getInitialProps fetching is handled in next/router
// this is for when ErrorComponent gets replaced by Component by HMR
if(!props&&Component&&Component!==ErrorComponent&&lastAppProps.Component===ErrorComponent){const _router=router,pathname=_router.pathname,query=_router.query,asPath=_router.asPath;props=await(0,_utils.loadGetInitialProps)(App,{Component,router,ctx:{err,pathname,query,asPath}});}Component=Component||lastAppProps.Component;props=props||lastAppProps.props;const appProps=(0,_extends2.default)({Component,err,router},props);// lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.
lastAppProps=appProps;emitter.emit('before-reactdom-render',{Component,ErrorComponent,appProps});// In development runtime errors are caught by react-error-overlay.
if(process.env.NODE_ENV==='development'){renderReactElement(_react.default.createElement(_react.Suspense,{fallback:_react.default.createElement("div",null,"Loading...")},_react.default.createElement(_routerContext.RouterContext.Provider,{value:(0,_router2.makePublicRouterInstance)(router)},_react.default.createElement(_dataManagerContext.DataManagerContext.Provider,{value:dataManager},_react.default.createElement(_headManagerContext.HeadManagerContext.Provider,{value:headManager.updateHead},_react.default.createElement(App,appProps))))),appContainer);}else{// In production we catch runtime errors using componentDidCatch which will trigger renderError.
renderReactElement(_react.default.createElement(_errorBoundary.ErrorBoundary,{fn:error=>renderError({App,err:error}).catch(err=>console.error('Error rendering page: ',err))},_react.default.createElement(_react.Suspense,{fallback:_react.default.createElement("div",null,"Loading...")},_react.default.createElement(_routerContext.RouterContext.Provider,{value:(0,_router2.makePublicRouterInstance)(router)},_react.default.createElement(_dataManagerContext.DataManagerContext.Provider,{value:dataManager},_react.default.createElement(_headManagerContext.HeadManagerContext.Provider,{value:headManager.updateHead},_react.default.createElement(App,appProps)))))),appContainer);}emitter.emit('after-reactdom-render',{Component,ErrorComponent,appProps});}