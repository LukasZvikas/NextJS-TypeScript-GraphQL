"use strict";var _mkdirp=_interopRequireDefault(require("mkdirp"));var _util=require("util");var _path=require("path");var _render=require("next-server/dist/server/render");var _fs=require("fs");var _asyncSema=_interopRequireDefault(require("async-sema"));var _amphtmlValidator=_interopRequireDefault(require("amphtml-validator"));var _loadComponents=require("next-server/dist/server/load-components");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const envConfig=require('next-server/config');const mkdirp=(0,_util.promisify)(_mkdirp.default);const writeFileP=(0,_util.promisify)(_fs.writeFile);const accessP=(0,_util.promisify)(_fs.access);global.__NEXT_DATA__={nextExport:true};process.on('message',async({distDir,buildId,exportPaths,exportPathMap,outDir,renderOpts,serverRuntimeConfig,concurrency,subFolders})=>{const sema=new _asyncSema.default(concurrency,{capacity:exportPaths.length});try{const work=async path=>{await sema.acquire();const ampPath=`${path==='/'?'/index':path}.amp`;const{page,query={}}=exportPathMap[path];delete query.ampOnly;delete query.hasAmp;delete query.ampPath;delete query.amphtml;const req={url:path};const res={};envConfig.setConfig({serverRuntimeConfig,publicRuntimeConfig:renderOpts.runtimeConfig});let htmlFilename=`${path}${_path.sep}index.html`;if(!subFolders)htmlFilename=`${path}.html`;const pageExt=(0,_path.extname)(page);const pathExt=(0,_path.extname)(path);// Make sure page isn't a folder with a dot in the name e.g. `v1.2`
if(pageExt!==pathExt&&pathExt!==''){// If the path has an extension, use that as the filename instead
htmlFilename=path;}else if(path==='/'){// If the path is the root, just use index.html
htmlFilename='index.html';}const baseDir=(0,_path.join)(outDir,(0,_path.dirname)(htmlFilename));const htmlFilepath=(0,_path.join)(outDir,htmlFilename);await mkdirp(baseDir);const components=await(0,_loadComponents.loadComponents)(distDir,buildId,page);const curRenderOpts={...components,...renderOpts,ampPath};const html=await(0,_render.renderToHTML)(req,res,page,query,curRenderOpts);const validateAmp=async(html,page)=>{const validator=await _amphtmlValidator.default.getInstance();const result=validator.validateString(html);const errors=result.errors.filter(e=>e.severity==='ERROR');const warnings=result.errors.filter(e=>e.severity!=='ERROR');if(warnings.length||errors.length){process.send({type:'amp-validation',payload:{page,result:{errors,warnings}}});}};if(curRenderOpts.amphtml&&query.amp){await validateAmp(html,path);}if(curRenderOpts.amphtml&&!query.amp||curRenderOpts.hasAmp){// we need to render a clean AMP version
const ampHtmlFilename=`${ampPath}${_path.sep}index.html`;const ampBaseDir=(0,_path.join)(outDir,(0,_path.dirname)(ampHtmlFilename));const ampHtmlFilepath=(0,_path.join)(outDir,ampHtmlFilename);try{await accessP(ampHtmlFilepath);}catch(_){// make sure it doesn't exist from manual mapping
const ampHtml=await(0,_render.renderToHTML)(req,res,page,{...query,amp:1},curRenderOpts);await validateAmp(ampHtml,page+'?amp=1');await mkdirp(ampBaseDir);await writeFileP(ampHtmlFilepath,ampHtml,'utf8');}}await writeFileP(htmlFilepath,html,'utf8');process.send({type:'progress'});sema.release();};await Promise.all(exportPaths.map(work));process.send({type:'done'});}catch(err){console.error(err);process.send({type:'error',payload:err});}});